Fetching data with Axios
  Axios is a popular JavaScript library used for making HTTP requests in React applications. It simplifies the process of communicating with APIs and other external resources. Axios offers features such as automatic JSON transformation, handling errors, and request cancellation. 


Why use Axios over Fetch?
Axios uses promises like Fetch but makes the syntax cleaner.
No need to parse responses manually.
Axios automatically detects HTTP errors (status codes).
Built-in Features: Interceptors, timeout, request cancellation, and more!
Handling asynchronous operations
Handling asynchronous operations in React is straight forward with hooks like useEffect and useState. By using async/await, you can write clean and maintainable code while effectively managing loading states and errors.

async Keyword
await Keyword

async and await are JavaScript keywords that simplify working with asynchronous code, making it easier to read and write. They are part of the Promises API and are used to handle asynchronous operations in a more synchronous-like manner.
1. async Keyword
The async keyword is used to declare an asynchronous function. An asynchronous function always returns a Promise, even if you return a non-Promise value.
When an async function is called, it returns a Promise that resolves with the value returned by the function or rejects with an error if an exception is thrown.

2. await Keyword
The await keyword can only be used inside an async function. It pauses the execution of the async function until the Promise is resolved or rejected.
When await is used, it allows you to write asynchronous code that looks synchronous, making it easier to read and maintain.
Integrating GraphQL with React
GraphQL is a query language for APIs and a runtime for executing those queries against your data. Developed by Facebook, it provides a more efficient, powerful, and flexible alternative to REST APIs. Instead of multiple endpoints, GraphQL allows clients to request exactly what they need from a single endpoint.


Why Use GraphQL?

Single Endpoint: Unlike REST, which requires multiple endpoints, GraphQL fetches data from a single endpoint.
Efficient Data Fetching: Clients request only the necessary data, reducing over-fetching or under-fetching.
Strongly Typed: GraphQL uses a schema to define the shape of the data, making it predictable and self-documenting.
Better Developer Experience: Built-in introspection and strong community support.
Queries:
Clients send queries to the GraphQL server to request specific data. A query specifies the shape of the data that the client wants.

Example Flow:

Client Sends Query: When the component mounts, the useQuery hook sends the GET_POSTS query to the GraphQL server.

Server Processes Query: The GraphQL server receives the query, processes it, and calls the appropriate resolvers to fetch the requested data.

Data Returned: The server returns the requested data in the shape specified by the query.

Client Receives Data: Apollo Client receives the data and updates the component state, causing the component to re-render with the fetched data.

Practical Tasks

Fetch a list of countries using GraphQL
  Use the API: https://countries.trevorblades.com/
   Query country names and their capitals.

Implement a search feature
   Modify the Pok√©mon example to allow users to search for Pok√©mon dynamically.

Add a user registration form
   Extend the AddUser component to display newly added users in a list.

Update user details using a mutation
   Create an UPDATE_USER mutation and use it to edit user information.

Display a paginated list of items
         Fetch paginated results using GraphQL queries and display them using React
Practical Tasks

Fetch a list of countries using GraphQL
  Use the API: https://countries.trevorblades.com/
   Query country names and their capitals.

Implement a search feature
   Modify the Pok√©mon example to allow users to search for Pok√©mon dynamically.

Add a user registration form
   Extend the AddUser component to display newly added users in a list.

Update user details using a mutation
   Create an UPDATE_USER mutation and use it to edit user information.

Display a paginated list of items
         Fetch paginated results using GraphQL queries and display them using React
Practical Tasks

Fetch a list of countries using GraphQL
  Use the API: https://countries.trevorblades.com/
   Query country names and their capitals.

Implement a search feature
   Modify the Pok√©mon example to allow users to search for Pok√©mon dynamically.

Add a user registration form
   Extend the AddUser component to display newly added users in a list.

Update user details using a mutation
   Create an UPDATE_USER mutation and use it to edit user information.

Display a paginated list of items
         Fetch paginated results using GraphQL queries and display them using React
Authentication and authorization are two distinct security processes crucial for managing user access in React applications. Authentication verifies the identity of a user, while authorization determines what an authenticated user is allowed to access.

Authentication
Authentication is the process of verifying a user's identity. It answers the question "Who is the user?". Common methods of authentication include:
Username and password:
Users provide their credentials, which are then checked against a database or authentication service.

Authorization
Authorization occurs after successful authentication and determines what an authenticated user can do. It answers the question "What can the user do?". Authorization is often implemented using roles and permissions. 
Example:
Admin: Has full access to all features and data.
Editor: Can create and edit content but cannot manage users.
Viewer: Can only view content.
The fundamental difference between authentication and authorization is that authentication is the process of verifying who someone is. In contrast, authorization is the process of verifying what specific applications, files, and data a user is authorized to access.
Here‚Äôs a step-by-step explanation of the React code:

1. Check `userRole`: The `Login` component checks if `userRole` exists using a ternary operator.
2.  Show Login Form: If `userRole` is empty, display a form with email/password inputs and a "Login" button.
3.  Handle Input: The email input updates the `email` state via `setEmail`; the password input updates the `password` state via `setPassword`.
4.  Trigger Login: Clicking the "Login" button calls `handleLogin` (not shown), which likely verifies credentials and sets `userRole`.
5.  Switch to Dashboard: If `userRole` exists (e.g., "student"), render the `Dashboard` component, passing `userRole` as a prop.
Display Welcome: `Dashboard` shows "Welcome, [ROLE]" (e.g., "STUDENT" in uppercase) with a party popper emoji.

Show Role-Specific Message: Based on `role`:
      "student": "You can access the Library üìö".   
      "teacher": "You can enter the Staff Room üè´".   
      "admin": "You have access to everything üõ†Ô∏è".
Real time data with web scokets
Integrating Web Sockets in React enables real-time, bidirectional communication between the client and server. This is achieved by establishing a persistent connection, allowing for instant data exchange without the overhead of repeatedly opening and closing HTTP connections.
A basic implementation involves the WebSocket API within a React component, typically using the useEffect hook for managing the connection lifecycle.

How does it work?

WebSocket Handshake: The communication begins with an HTTP handshake. The client sends a standard HTTP request with specific headers indicating a WebSocket upgrade request. If the server supports WebSockets, it sends back an HTTP 101 Switching Protocols response, confirming the upgrade.

Data Transfer: Once the handshake is complete, the HTTP connection is "upgraded" to a WebSocket connection. Data can then be exchanged in both directions using WebSocket frames, which are simpler and more lightweight than HTTP headers, further reducing overhead.

Connection Closure: The WebSocket connection remains open until either the client or the server explicitly closes it.
When you send an email/ message on chat, you have to wait for the other person to check their inbox. But when you send a WhatsApp message, it pops up instantly!


Email (HTTP Requests): Sent messages are stored on a server, and the recipient must refresh or check manually‚Äîcausing delays.

WhatsApp (WebSockets): Keeps a live connection open, instantly pushing messages without needing to refresh.
Key Difference: Email waits for a request, while WhatsApp receives updates instantly



When you use the WebSocket API directly, here are just some of the things you should be prepared to code yourself:

Authentication and authorization.
Robust disconnect detection by implementing a heartbeat.
Seamless automatic reconnection.
Recovering missed messages, the user missed while temporarily disconnected.
